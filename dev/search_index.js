var documenterSearchIndex = {"docs":
[{"location":"contributing.html#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Contributions are always welcome!","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"If you want to contribute features, bug fixes, etc, please take a look at our Code Style Guide below\nPlease report any issues and bugs that you encounter in Issues\nAs an open source project we are also interested in any projects and applications that use Dojo. Please let us know via email to: thowell@stanford.edu or simonlc@stanford.edu","category":"page"},{"location":"contributing.html#Potentially-Useful-Contributions","page":"Contributing","title":"Potentially Useful Contributions","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Here are a list of current to-do's that would make awesome contributions:","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"improved parsing of URDF files\njoint limits, friction coefficients\nimproved collision detection \nbody-to-body contact \ngeneral convex shapes \ncurved surfaces \nGPU support \nnice REPL interface\ninteractive GUI","category":"page"},{"location":"contributing.html#Code-Style-Guide","page":"Contributing","title":"Code Style Guide","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"The code in this repository follows the naming and style conventions of Julia Base with a few modifications. This style guide is heavily \"inspired\" by the guides of John Myles White, JuMP, and COSMO","category":"page"},{"location":"contributing.html#Formatting","page":"Contributing","title":"Formatting","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Use one tab when indenting a new block (except module)\nUse spaces between operators, except for ^, ', and :\nUse single space after commas and semicolons\nDon't use spaces around parentheses, or braces","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Bad: f(x,y) = [5*sin(x+y);y'] Good: f(x, y) = [5 * sin(x + y); y']","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Use spacing with keyword arguments","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Bad: foo(x::Float; y::Integer = 1) Good: foo(x::Float; y::Integer=1)","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Don't parenthesize conditions","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Bad: if (a == b) Good: if a == b","category":"page"},{"location":"contributing.html#Naming","page":"Contributing","title":"Naming","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Modules and Type names use capitilization and camel case, e.g. module LinearAlgebra, struct ConvexSets.\nFunctions are lowercase and use underscores to seperate words, e.g. has_key(x), is_valid(y).\nNormal variables are lowercase and use underscores like functions, e.g. convex_set\nConstants are uppercase, e.g. const MY_CONSTANT\nAlways append ! to names of functions that modify their arguments.\nFunction arguments that are mutated come first. Otherwise follow the rules layed out in Julia Base Argument ordering\nFiles are named like functions, e.g. my_new_file.jl","category":"page"},{"location":"contributing.html#Syntax","page":"Contributing","title":"Syntax","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Use 1.0 instead of 1.","category":"page"},{"location":"install.html#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"load_mechanism.html#Loading-Mechanism-via-URDF","page":"Loading Mechanism via URDF","title":"Loading Mechanism via URDF","text":"","category":"section"},{"location":"load_mechanism.html","page":"Loading Mechanism via URDF","title":"Loading Mechanism via URDF","text":"Another way to build a mechanism is to directly load it from a URDF file. We illustrate this with the RExLab hopper.","category":"page"},{"location":"load_mechanism.html","page":"Loading Mechanism via URDF","title":"Loading Mechanism via URDF","text":"function get_rexhopper(;\n    timestep=0.01,\n    gravity=[0.0; 0.0; -9.81],\n    friction_coefficient=1.0,\n    contact_body=true,\n    limits=true,\n    model=:rexhopper,\n    floating=true,\n    contact_type=:nonlinear,\n    spring=0.0,\n    damper=1.0,\n    T=Float64)\n\n    # we define the path of the URDF file\n    path = joinpath(@__DIR__, \"../deps/$(String(model)).urdf\")\n    # we load the URDF file into a Mechanism object\n    mech = Mechanism(path, floating, T,\n        gravity=gravity,\n        timestep=timestep,\n        spring=spring,\n        damper=damper)\n    return mech\nend","category":"page"},{"location":"load_mechanism.html","page":"Loading Mechanism via URDF","title":"Loading Mechanism via URDF","text":"Here, we have created a mechanism, that contains all the bodies and the joint and also the meshes loaded from the path contained in the URDF file. This is the resulting robot; (Image: rexhopper)","category":"page"},{"location":"load_mechanism.html","page":"Loading Mechanism via URDF","title":"Loading Mechanism via URDF","text":"However, we are still missing the joint limits and the contact spheres. The following methods provides an example for adding joint limits and contact spheres. Our goal here was to best approximate the mesh shapes using as few spheres as possible. Parsing joint limits from the URDF to add them automatically to the mechanism should be easily feasible. That could be a great way to contribute and familiarize yourself with the code!","category":"page"},{"location":"load_mechanism.html","page":"Loading Mechanism via URDF","title":"Loading Mechanism via URDF","text":"function get_rexhopper(;\n    timestep=0.01,\n    gravity=[0.0; 0.0; -9.81],\n    friction_coefficient=1.0,\n    contact_body=true,\n    limits=true,\n    model=:rexhopper,\n    floating=true,\n    contact_type=:nonlinear,\n    spring=0.0,\n    damper=1.0,\n    T=Float64)\n\n    # we define the path of the URDF file\n    path = joinpath(@__DIR__, \"../deps/$(String(model)).urdf\")\n    # we load the URDF file into a Mechanism object\n    mech = Mechanism(path, floating, T,\n        gravity=gravity,\n        timestep=timestep,\n        spring=spring,\n        damper=damper)\n\n    # we add joint limits to the mechanism\n    joints = deepcopy(mech.joints)\n    if limits\n        joint1 = get_joint(mech, :joint1)\n        joint3 = get_joint(mech, :joint3)\n        joints[joint1.id] = add_limits(mech, joint1,\n            rot_limits=[SVector{1}(-0.7597), SVector{1}(1.8295)])\n        joints[joint3.id] = add_limits(mech, joint3,\n            rot_limits=[SVector{1}(-1.8295), SVector{1}(0.7597)])\n        mech = Mechanism(Origin{T}(), [mech.bodies...], [joints...],\n            gravity=gravity,\n            timestep=timestep,\n            spring=spring,\n            damper=damper)\n    end\n\n    # we attach spherical collisions zones to certain bodies\n    if contact_body\n        origin = Origin{T}()\n        bodies = mech.bodies\n        joints = mech.joints\n\n        normal = [0.0; 0.0; 1.0]\n        contacts = []\n\n        link3 = get_body(mech, :link3)\n        link2 = get_body(mech, :link2)\n        foot_radius = 0.0203\n        ankle_radius = 0.025\n        base_radius = 0.125\n        p = [0.1685; 0.0025; -0.0055]\n        o = [0;0; foot_radius]\n        push!(contacts, contact_constraint(link3, normal,\n            friction_coefficient=friction_coefficient,\n            contact_point=p,\n            offset=o,\n            contact_type=contact_type,\n            name=:foot))\n        p = [-0.10; -0.002; 0.01]\n        o = [0;0; ankle_radius]\n        push!(contacts, contact_constraint(link3, normal,\n            friction_coefficient=friction_coefficient,\n            contact_point=p,\n            offset=o,\n            contact_type=contact_type,\n            name=:ankle3))\n        p = [0.24; 0.007; 0.005]\n        push!(contacts, contact_constraint(link2, normal,\n            friction_coefficient=friction_coefficient,\n            contact_point=p,\n            offset=o,\n            contact_type=contact_type,\n            name=:ankle2))\n        base_link = get_body(mech, :base_link)\n        p = [0.0; 0.0; 0.0]\n        o = [0;0; base_radius]\n        push!(contacts, contact_constraint(base_link, normal,\n            friction_coefficient=friction_coefficient,\n            contact_point=p,\n            offset=o,\n            contact_type=contact_type,\n            name=:torso))\n\n        set_minimal_coordinates!(mech, get_joint(mech, :floating_base), [0,0,1.0, 0,0,0])\n        mech = Mechanism(origin, bodies, joints, [contacts...],\n            gravity=gravity,\n            timestep=timestep,\n            spring=spring,\n            damper=damper)\n    end\n    return mech\nend","category":"page"},{"location":"load_mechanism.html","page":"Loading Mechanism via URDF","title":"Loading Mechanism via URDF","text":"This is the result, we added three spherical contacts to the robot. There is one coverinn the torso one covering the knee and one covering the foot, they are shown in red; (Image: rexhopper_contact)","category":"page"},{"location":"reinforcement_learning.html#Reinforcement-Learning","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"","category":"section"},{"location":"reinforcement_learning.html","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"Policy optimization is performed using the reinforcement-learning algorithm augmented random search (ARS) to optimize static linear policies for locomotion. A number of Gym-like environments are created with Dojo for this application.","category":"page"},{"location":"reinforcement_learning.html#[Half-Cheetah](https://github.com/dojo-sim/Dojo.jl/blob/main/examples/reinforcement_learning/halfcheetah_ars.jl)","page":"Reinforcement Learning","title":"Half Cheetah","text":"","category":"section"},{"location":"reinforcement_learning.html","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"<img src=\"./assets/animations/halfcheetah_ars.gif\" width=\"600\"/>","category":"page"},{"location":"reinforcement_learning.html","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"The cheetah-like robot has rewards on forward velocity and costs on control usage. ","category":"page"},{"location":"reinforcement_learning.html#[Ant](https://github.com/dojo-sim/Dojo.jl/blob/main/examples/reinforcement_learning/ant_ars.jl)","page":"Reinforcement Learning","title":"Ant","text":"","category":"section"},{"location":"reinforcement_learning.html","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"<img src=\"./assets/animations/ant_ars_no_grid.gif\" width=\"300\"/>","category":"page"},{"location":"reinforcement_learning.html","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"The insect-like robot has rewards on forward velocity and survival and costs on control usage and contact forces.","category":"page"},{"location":"reinforcement_learning.html#Gradient-Free","page":"Reinforcement Learning","title":"Gradient-Free","text":"","category":"section"},{"location":"reinforcement_learning.html","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"The original ARS is a derivative-free algorithm and only utilizes the relative costs for each sample policy in order to assemble a new search direction for the policy parameters. While this approach is general, it is potentially very sample inefficient.","category":"page"},{"location":"reinforcement_learning.html#Gradient-Based","page":"Reinforcement Learning","title":"Gradient-Based","text":"","category":"section"},{"location":"reinforcement_learning.html","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"We formulate a gradient-based version, augmented gradient search (AGS), that utilizes gradients from Dojo. We find that by using this information the policy optimization can often be an order of magntitude more sample efficient in terms of queries to the simulator.","category":"page"},{"location":"gym_env.html#Gym","page":"Gym","title":"Gym","text":"","category":"section"},{"location":"impact.html#Impact","page":"Impact","title":"Impact","text":"","category":"section"},{"location":"impact.html#Mathematical-Model","page":"Impact","title":"Mathematical Model","text":"","category":"section"},{"location":"impact.html","page":"Impact","title":"Impact","text":"We model hard contact via constraints on the system’s configuration and the applied contact forces. For a system with P contact points, we define a signed-distance function,","category":"page"},{"location":"impact.html","page":"Impact","title":"Impact","text":"phi  mathbfZ rightarrow mathbfR^P","category":"page"},{"location":"impact.html","page":"Impact","title":"Impact","text":"subject to the following element-wise constraint:","category":"page"},{"location":"impact.html","page":"Impact","title":"Impact","text":"ϕ(z)  0","category":"page"},{"location":"impact.html","page":"Impact","title":"Impact","text":"Impact forces with magnitude gamma in mathbfR^P are applied to the bodies’ contact points in the direction of their surface normals in order to enforce (5) and prevent interpenetration. A non-negative constraint,","category":"page"},{"location":"impact.html","page":"Impact","title":"Impact","text":"gamma geq 0","category":"page"},{"location":"impact.html","page":"Impact","title":"Impact","text":"enforces physical behavior that impulses are repulsive (e.g., the floor does not attract bodies), and the complementarity condition,","category":"page"},{"location":"impact.html","page":"Impact","title":"Impact","text":"gamma circ phi(z) = 0","category":"page"},{"location":"impact.html","page":"Impact","title":"Impact","text":"where circ is an element-wise product operator, enforces zero force if the body is not in contact and allows non-zero force during contact.","category":"page"},{"location":"quadruped_env.html#Quadruped","page":"Quadruped","title":"Quadruped","text":"","category":"section"},{"location":"classic_env.html#Classic","page":"Classic","title":"Classic","text":"","category":"section"},{"location":"define_mechanism.html#Defining-a-Mechanism","page":"Defining a Mechanism","title":"Defining a Mechanism","text":"","category":"section"},{"location":"define_mechanism.html","page":"Defining a Mechanism","title":"Defining a Mechanism","text":"Here, we describe how to define your own dynamical system of Mechanism. After it has been defined, it will be extremely easy to simulate it, control it, perform trajectory optimization on it, or even policy optimization.","category":"page"},{"location":"define_mechanism.html","page":"Defining a Mechanism","title":"Defining a Mechanism","text":"We're going to build a tippe top,","category":"page"},{"location":"define_mechanism.html","page":"Defining a Mechanism","title":"Defining a Mechanism","text":"<img src=\"./assets/tippetop_real.gif\" width=\"300\"/>","category":"page"},{"location":"define_mechanism.html","page":"Defining a Mechanism","title":"Defining a Mechanism","text":"<img src=\"./assets/animations/tippetop.gif\" width=\"300\"/>","category":"page"},{"location":"define_mechanism.html#Build-Mechanism","page":"Defining a Mechanism","title":"Build Mechanism","text":"","category":"section"},{"location":"define_mechanism.html","page":"Defining a Mechanism","title":"Defining a Mechanism","text":"To do this, we need to define two methods. The first one is named get_... where ... is the name of the mechanism. So here we define get_tippetop. This function return a Mechanism and takes as input a variety of parameters like the simulation time step, gravity etc. You can add as many parameters you want. This example is typical of what you will find in Dojo.","category":"page"},{"location":"define_mechanism.html","page":"Defining a Mechanism","title":"Defining a Mechanism","text":"To build the mechanism corresponding to the tippe top, we decompose it into two spherical bodies. Each body has its own spherical contact constraint with the floor. The joint between the two bodies is a fixed_joint and the joint between the main body and the Origin of the frame is a floating joint.","category":"page"},{"location":"define_mechanism.html","page":"Defining a Mechanism","title":"Defining a Mechanism","text":"function get_tippetop(;\n    timestep=0.01,\n    gravity=[0.0; 0.0; -9.81],\n    friction_coefficient=0.4,\n    contact_type=:nonlinear,\n    T=Float64)\n\n    # define origin\n    origin = Origin{T}(name=:origin)\n    # define the two bodies which will form the tippe top once assembled\n    radius = 0.5\n    mass = 1.0\n    α = 0.2\n    bodies = [\n        Sphere(radius, mass, name=:sphere1, color=gray_light),\n        Sphere(radius*α, mass*α^3, name=:sphere2, color=gray_light)]\n    # modify inertia of the first body to ensure we obtain the desired behavior\n    bodies[1].inertia = Diagonal([1.9, 2.1, 2.0])\n\n    # define the joints, the 1st joint is between Origin and :sphere1\n    # the 2nd joint is between :sphere1 and :sphere2\n    joints = [\n        JointConstraint(Floating(origin, bodies[1]),\n                name=:floating_joint),\n        JointConstraint(Fixed(bodies[1], bodies[2],\n                parent_vertex=[0,0,radius],\n                child_vertex=zeros(3)),\n                name = :fixed_joint)]\n\n    # define the two spherical contacts, each contact is attached to a body.\n    contact_point = [0.0, 0.0, 0.0] # both contact spheres are located at the center of the bodies they are attached to.\n    normal = [0.0, 0.0, 1.0] # the normal of the contact is always pointing in the upright direction because the floor is flat.\n    # we specify the type of contact (impact, linear, nonlinear), the coefficient of friction, the radius of the contact sphere, etc.\n    contacts = [\n        contact_constraint(get_body(mechanism, :sphere1), normal,\n            friction_coefficient=friction_coefficient,\n            contact_point=contact_point, offset=[0.0, 0.0, radius],\n            contact_type=contact_type),\n        contact_constraint(get_body(mechanism, :sphere2), normal,\n            friction_coefficient=friction_coefficient,\n            contact_point=contact_point,\n            offset=[0.0, 0.0, radius * α],\n            contact_type=contact_type)\n        ]\n\n    # we build the mechanism by combining together the the origin, the bodies, the joints, and the contacts.\n    mechanism = Mechanism(origin, bodies, joints, contacts,\n        gravity=gravity,\n        timestep=timestep)\n\n    # we make sure that the mechanism is never initialized with its contact spheres below the ground.\n    set_minimal_coordinates!(mechanism, get_joint(mechanism, :floating_joint), [0.0; 0.0; radius; zeros(3)])\n    return mechanism\nend","category":"page"},{"location":"define_mechanism.html#Initialize-Mechanism","page":"Defining a Mechanism","title":"Initialize Mechanism","text":"","category":"section"},{"location":"define_mechanism.html","page":"Defining a Mechanism","title":"Defining a Mechanism","text":"The second method that we need to define is initialize_... where ... is the name of the mechanism. So here we define initialize_tippetop. This function initialize the dynamical system to a certain state. This means that we set the position orientation, linear and angular velocity of each body in the mechanism.","category":"page"},{"location":"define_mechanism.html","page":"Defining a Mechanism","title":"Defining a Mechanism","text":"function initialize_tippetop!(mechanism::Mechanism{T};\n    body_position=zeros(3),\n    body_orientation=zeros(3),\n    body_linear_velocity=zeros(3),\n    body_angular_velocity=zeros(3)) where T\n\n    # we retrieve the joints from the mechanism by their names\n    floating_joint = get_joint(mechanism, :floating_joint)\n    fixed_joint = get_joint(mechanism, :fixed_joint)\n    radius = fixed_joint.translational.vertices[1][3]\n\n    # we set all the bodies' velocities to zeros\n    zero_velocity!(mechanism)\n    # we set to minimal coordinates of the floating joint\n    set_minimal_coordinates_velocities!(mechanism, floating_joint,\n        xmin=[body_position; body_orientation; body_linear_velocity; body_angular_velocity])\n    # we set to minimal coordinates of the fixed joint (this joint has zero minimal coordinate).\n    set_minimal_coordinates_velocities!(mechanism, fixed_joint)\n    return nothing\nend","category":"page"},{"location":"minimal_representation.html#Minimal-Coordinates","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"","category":"section"},{"location":"minimal_representation.html","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"Dojo simulates systems in maximal coordinates. ","category":"page"},{"location":"minimal_representation.html","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"For a mechanism with M joints and N bodies, the maximal representation z can be efficiently converted to minimal coordinates: ","category":"page"},{"location":"minimal_representation.html","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"y = (y^(1) dots y^(M)) leftarrow z = (z^(1) dots z^(N))","category":"page"},{"location":"minimal_representation.html","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"where y^(j) depends on the degree and type of joint. Note: this minimal representation does not stack coordinates followed by velocities, which is a common convention; instead, coordinates and velocities are grouped by joint.","category":"page"},{"location":"minimal_representation.html","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"Each minimal state comprises:","category":"page"},{"location":"minimal_representation.html","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"y = (p_texttranslational p_textrotational w_texttranslational w_textrotational)","category":"page"},{"location":"minimal_representation.html","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"coordinates p and velocities w for both translational and rotational degrees of freedom.","category":"page"},{"location":"minimal_representation.html","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"In the case of a floating-base joint, the minimal-representation orientation is converted to modified Rodrigues parameters from a unit quaternion.","category":"page"},{"location":"trajectory_optimization.html#Trajectory-Optimization","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"","category":"section"},{"location":"trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"Dojo provides dynamics constraints and Jacobians in order to perform trajectory optimization using iterative LQR. ","category":"page"},{"location":"trajectory_optimization.html#[Quadruped](https://github.com/dojo-sim/Dojo.jl/blob/main/examples/trajectory_optimization/quadruped_min.jl)","page":"Trajectory Optimization","title":"Quadruped","text":"","category":"section"},{"location":"trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"<img src=\"./assets/animations/quadruped_min.gif\" width=\"200\"/>","category":"page"},{"location":"trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"A Unitree A1 takes a number of forward steps. There are costs on a kinematic gait and control usage, as well as an augmented Lagrangian (i.e., soft) constraint on the the robot's final pose. The maximal representation is converted to a minimal one for optimization. Additionally, slack controls are utilized early on to aid the optimizer before being driven to zero by a constraint to achieve a dynamically feasible trajectory.","category":"page"},{"location":"trajectory_optimization.html#[Atlas](https://github.com/dojo-sim/Dojo.jl/blob/main/examples/trajectory_optimization/atlas_min.jl)","page":"Trajectory Optimization","title":"Atlas","text":"","category":"section"},{"location":"trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"<img src=\"./assets/animations/atlas_ilqr.gif\" width=\"200\"/>","category":"page"},{"location":"trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"The Atlas v5 humanoid (sans arms) takes a number of forward steps. Similar to the quadruped example, there are costs on control effort and deviations from a kinematic plan, a minimal representation is utilized, and the optimizer is aided by slack controls.","category":"page"},{"location":"trajectory_optimization.html#[Block](https://github.com/dojo-sim/Dojo.jl/blob/main/examples/trajectory_optimization/box.jl)","page":"Trajectory Optimization","title":"Block","text":"","category":"section"},{"location":"trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"<img src=\"./assets/animations/box_right.gif\" width=\"200\"/>","category":"page"},{"location":"trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"A block is moved to a goal location by applying forces to its center of mass. The optimizer is initialized with zero control and utilizes smooth gradients from Dojo to find a motion that overcomes friction to slide towards the goal.","category":"page"},{"location":"trajectory_optimization.html#[Raibert-Hopper](https://github.com/dojo-sim/Dojo.jl/blob/main/examples/trajectory_optimization/hopper_max.jl)","page":"Trajectory Optimization","title":"Raibert Hopper","text":"","category":"section"},{"location":"trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"<img src=\"./assets/animations/hopper_max.gif\" width=\"100\"/>","category":"page"},{"location":"trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"A hopping robot, inspired by the Raibert Hopper, is tasked with moving to a goal location. The optimizer finds a single hop trajectory to reach its goal pose.","category":"page"},{"location":"trajectory_optimization.html#[Cart-pole](https://github.com/dojo-sim/Dojo.jl/blob/main/examples/trajectory_optimization/cartpole_max.jl)","page":"Trajectory Optimization","title":"Cart-pole","text":"","category":"section"},{"location":"trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"<img src=\"./assets/animations/cartpole_max.gif\" width=\"200\"/>","category":"page"},{"location":"trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"This classic system is tasked with performing a swing-up. Examples are provided performing optimization with both maximal and minimal representations. ","category":"page"},{"location":"define_environment.html#Defining-an-Environment","page":"Defining an Environment","title":"Defining an Environment","text":"","category":"section"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"An Environment is a convienient object for applications like reinforcement learning and trajectory optimization. ","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"To demonstrate, we create the Dojo.Ant environment. First, we load (or create) a mechanism:","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"mechanism = get_mechanism(:ant) ","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"Next, we create an environment's other attributes.","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"Dimensions:","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"# set state dimension based on representation\nif representation == :minimal\n    nx = minimal_dimension(mechanism)\nelseif representation == :maximal\n    nx = maximal_dimension(mechanism)\nend\n# set control dimension\nnu = 8\n# set observation dimension\nno = nx","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"Space (for limiting controls and observations):","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"# limit controls to [-1.0, 1.0]\naspace = BoxSpace(nu, \n    low=(-ones(nu)), \n    high=(ones(nu)))\n# no limits on observations\nospace = BoxSpace(no, \n    low=(-Inf * ones(no)), \n    high=(Inf * ones(no)))","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"Random number:","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"rng = MersenneTwister(seed)","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"Dynamics data:","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"# state vector\nz = get_maximal_state(mechanism)\nx = representation == :minimal ? maximal_to_minimal(mechanism, z) : z\n# dynamics Jacobians\nfx = zeros(nx, nx)\nfu = zeros(nx, nu)","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"Control data: ","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"# control vector (previous)\nu_prev = zeros(nu)\n# control map transforms inputs from control to dynamics space\ncontrol_mask = [zeros(8, 6) I(nu)]\ncontrol_scaling = Diagonal(timestep * 150.0 * ones(nu))\ncontrol_map = control_mask' * control_scaling","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"Visuals: ","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"# create a visualizer\nvis = Visualizer() ","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"Solver options: ","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"# simulation options \nopts_step = SolverOptions()\n# gradient options\nopts_grad = SolverOptions() ","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"Environment:","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"TYPES = [Ant, T, typeof(mechanism), typeof(aspace), typeof(ospace), typeof(info)]\nenv = Environment{TYPES...}(\n    mechanism, \n    representation, \n    aspace, ospace,\n    x, fx, fu,\n    u_prev, \n    control_map,\n    nx, nu, no,\n    info,\n    [rng], \n    vis,\n    opts_sim, opts_grad)","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"With the environment instantiated, we can interact with it by overloading the following methods: ","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"Simulate environment forward one time step:","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"function step(env::Environment{Ant}, x, u; \n    gradients=false,\n    attitude_decompress=false)\n\n    # mechanism\n    mechanism = env.mechanism\n\n    # timestep \n    timestep = mechanism.timestep\n\n    # copy current state\n    x0 = copy(x)\n\n    # cache current control\n    env.input_previous .= u  # for rendering in Gym\n\tu_scaled = env.control_map * u\n\n    # representation conversion\n    z0 = env.representation == :minimal ? minimal_to_maximal(mechanism, x0) : x0\n\n    # simulate one step\n    z1 = step!(mechanism, z0, u_scaled; opts=env.opts_step)\n\n    # representation conversion\n    env.state .= env.representation == :minimal ? maximal_to_minimal(mechanism, z1) : z1\n\n    # cost/reward\n    reward = cost(env, z1, u_scaled)\n\n    # check for done\n    done = is_done(env, z1, u_scaled)\n\n    # gradients\n    if gradients\n        if env.representation == :minimal\n            fx, fu = get_minimal_gradients!(env.mechanism, z0, u_scaled, opts=env.opts_grad)\n        elseif env.representation == :maximal\n            fx, fu = get_maximal_gradients!(env.mechanism, z0, u_scaled, opts=env.opts_grad)\n            if attitude_decompress\n                A0 = attitude_jacobian(z0, length(env.mechanism.bodies))\n                A1 = attitude_jacobian(z1, length(env.mechanism.bodies))\n                fx = A1 * fx * A0'\n                fu = A1 * fu\n            end\n        end\n        env.dynamics_jacobian_state .= fx\n        env.dynamics_jacobian_input .= fu * env.control_map\n    end\n\n    # information\n    info = Dict()\n\n    return get_observation(env), reward, done, info\nend","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"Return environment to nominal state:","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"function Base.reset(env::Environment{Ant}; \n    x=nothing)\n\n    # initialize\n    initialize!(env.mechanism, type2symbol(Ant))\n\n    if x != nothing\n        env.state .= x\n    else\n        x = get_minimal_state(env.mechanism)\n        if env.representation == :minimal\n            set_maximal_state!(env.mechanism, minimal_to_maximal(env.mechanism, x))\n            env.state .= x\n        elseif env.representation == :maximal\n            z = minimal_to_maximal(env.mechanism, x)\n            set_maximal_state!(env.mechanism, z)\n            env.state .= z\n        end\n        env.input_previous .= 0.0\n    end\n\n    return get_observation(env)\nend","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"Observation for current environment state:","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"function get_observation(env::Environment{Ant})\n    contact_force = Float64[]\n    for contact in env.mechanism.contacts\n        push!(contact_force, max(-1.0, min(1.0, contact.impulses[2][1])))\n    end\n    # include contact forces with state for observation\n    return [env.state; contact_force]\nend","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"Cost/reward associated with simulation step:","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"function cost(env::Environment{Ant}, x, u)\n    # forward reward\n    v = x[4] # x-direction velocity\n    forward_reward = 2.0 * v\n\n    # control cost\n\tctrl_cost = (0.05 * u' * u)[1]\n\n    # contact cost\n    contact_cost = 0.0\n\n    for contact in mechanism.contacts\n        contact_cost += 0.5 * 1.0e-3 * max(-1.0, min(1.0, contact.impulses[2][1]))^2.0\n    end\n\n\t# survive_reward = 1.0\n    survive_reward = 0.05\n\n    # total reward\n    reward = forward_reward - ctrl_cost - contact_cost + survive_reward\nend","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"Determine if simulation should terminate:","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"function is_done(env::Environment{Ant}, x) \n    !(all(isfinite.(env.state)) && (env.state[3] >= 0.2) && (env.state[3] <= 1.0))\nend","category":"page"},{"location":"define_environment.html#Random-controls","page":"Defining an Environment","title":"Random controls","text":"","category":"section"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"We apply random controls to the robot via the environment interface:","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"y = [copy(env.state)] # state trajectory\nfor t = 1:100\n    step(env, env.state, randn(env.num_inputs))\n    push!(y, copy(env.state)) \nend\nvisualize(env, y)","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"The result should be something like this:","category":"page"},{"location":"define_environment.html","page":"Defining an Environment","title":"Defining an Environment","text":"<img src=\"./assets/animations/ant_random.gif\" width=\"300\"/>","category":"page"},{"location":"faq.html#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"solver_options.html#Solver-Options","page":"Solver Options","title":"Solver Options","text":"","category":"section"},{"location":"solver_options.html","page":"Solver Options","title":"Solver Options","text":"The solver has several options accessible via SolverOptions. Below is a list describing their effect on the solver's behavior, typical values, and if they need to be tuned by the user.","category":"page"},{"location":"solver_options.html","page":"Solver Options","title":"Solver Options","text":"option default range effect tuning\nrtol 10^-4 10^-6 10^-2 larger leads to faster solve (usually takes the same value as btol) rarely\nbtol 10^-4 10^-6 10^-2 larger results in smoothed contact dynamics and faster solve rarely\nls_scale 05 03 08 larger potentially increase step size at the cost of more residual evaluations never\nmax_ls 10 1 25 larger allows for taking smaller steps never\nundercut +infty 2 +infty larger is more robust but can generate stiffer gradients rarely\nno_progress_max 3 3 5 smaller will increase the undercut faster never\nno_progress_undercut 10 3 100 larger will increase the undercut faster never\nverbose textfalse texttrue textfalse printing the status of the solver often","category":"page"},{"location":"define_controller.html#Defining-a-Controller","page":"Defining a Controller","title":"Defining a Controller","text":"","category":"section"},{"location":"define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"Here, we explain how to write a controller and simulate its effect on a dynamical system i.e., a Mechanism. We focus on a simple pendulum swing-up.","category":"page"},{"location":"define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"Load Dojo and use the pendulum mechanism with desired simulation time step, desired gravity and desired damping at the joint.","category":"page"},{"location":"define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"using Dojo\n\nmechanism = get_mechanism(:pendulum,\n    timestep=0.01,\n    gravity=-9.81,\n    damper=5.0)","category":"page"},{"location":"define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"Define the controller. This is a method that takes 2 input arguments:","category":"page"},{"location":"define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"a Mechanism,\nan integer t indicating the current simulation step.","category":"page"},{"location":"define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"The controller computes the control inputs based on the current state x, the goal state x_goal and a proportional gain K.","category":"page"},{"location":"define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"function controller!(mechanism, t)\n    ## Target state\n    x_goal = [1.0 * π; 0.0]\n\n    ## Current state\n    x = get_minimal_state(mechanism)\n\n    ## Gains\n    K = [5.0 0.5] * 0.1\n\n    # Control inputs\n    u =  -K * (x - x_goal)\n    set_input!(mechanism, u)\nend","category":"page"},{"location":"define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"We initialize the pendulum in the lower position, and we will let the controller perform the swing-up movement.","category":"page"},{"location":"define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"initialize!(mechanism, :pendulum,\n    angle=0.0 * π,\n    angular_velocity=0.0);","category":"page"},{"location":"define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"We simulate the system for 2 seconds using the controller!.","category":"page"},{"location":"define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"storage = simulate!(mechanism, 2.0, controller!,\n    record=true,\n    verbose=true);","category":"page"},{"location":"define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"We visualize the results.","category":"page"},{"location":"define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"vis = Visualizer()\nopen(vis)\nvisualize(mechanism, storage, vis=vis);","category":"page"},{"location":"define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"You should get something like this,","category":"page"},{"location":"define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"<img src=\"./assets/animations/pendulum.gif\" width=\"300\"/>","category":"page"},{"location":"api.html#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Docstrings for Dojo.jl interface members can be accessed through Julia's built-in documentation system or in the list below.","category":"page"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Dojo","category":"page"},{"location":"api.html#Contents","page":"API Documentation","title":"Contents","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api.html#Index","page":"API Documentation","title":"Index","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api.html#Mechanism","page":"API Documentation","title":"Mechanism","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Mechanism\nget_mechanism\ninitialize!\nget_node\nget_body\nget_joint\nget_contact\nget_maximal_state\nget_next_state\nget_minimal_state\nset_maximal_state!\nset_minimal_state!\nset_input!\nmaximal_dimension \nminimal_dimension\ninput_dimension\nzero_velocity!\nroot_to_leaves_ordering\nset_floating_base","category":"page"},{"location":"api.html#Dojo.Mechanism","page":"API Documentation","title":"Dojo.Mechanism","text":"Mechanism{T}\n\nMulti-rigid-body system. \n\norigin: global reference frame represented with Origin\njoints: list of JointConstraint objects\nbodies: list of Body objects\ncontacts: list of ContactConstraint objects\nsystem: graph-based representation for mechanism\nresidual_entries: containt entries for linear system residual\nmatrix_entries: contains entries for linear system matrix\ndiagonal_inverses: contains inverted matrices computing during LU factorization\ndata_matrix: contains parameter information that is fixed during simulation\nroot_to_leaves: list of node connections traversing from root node to leaves\ntimestep: time discretization\ngravity: force vector resulting from gravitational potential\nμ: complementarity violation (contact softness)\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.get_mechanism","page":"API Documentation","title":"Dojo.get_mechanism","text":"get_mechanism(model; kwargs...)\n\nconstructs mechanism\n\nmodel: name of mechanism \nkwargs: mechanism specific parameters\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.initialize!","page":"API Documentation","title":"Dojo.initialize!","text":"initialize!(mechanism, model; kwargs)\n\nstate initialization for mechanism \n\nmechanism: Mechanism \nmodel: name of mechanism \nkwargs: mechanism specific parameters\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_node","page":"API Documentation","title":"Dojo.get_node","text":"get_node(mechanism, name) \n\nreturn Node from Mechanism \n\nmechanism: Mechanism \nname: unique identifier for node\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_body","page":"API Documentation","title":"Dojo.get_body","text":"get_body(mechanism, name) \n\nreturns Body from Mechanism\n\nmechanism: Mechanism \nname: unique identifier for body\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_joint","page":"API Documentation","title":"Dojo.get_joint","text":"get_joint(mechanism, name) \n\nreturn JointConstraint from Mechanism \n\nmechanism: Mechanism \nname: unique identifier for joint\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_contact","page":"API Documentation","title":"Dojo.get_contact","text":"get_contact(mechanism, name) \n\nreturns ContactConstraint from Mechanism \n\nmechanism: Mechanism \nname: unique identifier for contact\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_maximal_state","page":"API Documentation","title":"Dojo.get_maximal_state","text":"get_maximal_state(mechanism) \n\nreturn the current maximal state of mechanism \n\nmechanism: Mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_next_state","page":"API Documentation","title":"Dojo.get_next_state","text":"get_next_state(mechanism) \n\nreturn the maximal state of mechanism after one simulation step\n\nmechanism: Mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_minimal_state","page":"API Documentation","title":"Dojo.get_minimal_state","text":"get_minimal_state(mechanism) \n\nreturn minimal state for mechanism \n\nmechanism: Mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_maximal_state!","page":"API Documentation","title":"Dojo.set_maximal_state!","text":"set_maximal_state(mechanism, z) \n\nset the maximal state of a mechanism \n\nmechanism: Mechanism \nz: state\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_minimal_state!","page":"API Documentation","title":"Dojo.set_minimal_state!","text":"set_minimal_state(mechanism, y) \n\nset the maximal state of a mechanism \n\nmechanism: Mechanism \ny: state\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_input!","page":"API Documentation","title":"Dojo.set_input!","text":"set_input(mechanism, u) \n\nset input for each joint in mechanism \n\nmechanism: Mechanism \nu: input\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.maximal_dimension","page":"API Documentation","title":"Dojo.maximal_dimension","text":"maximal_dimension(mechanism) \n\ndimension of a mechanism's maximal representation \n\nmechanism: Mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.minimal_dimension","page":"API Documentation","title":"Dojo.minimal_dimension","text":"minimal_dimension(mechanism) \n\ndimension of a mechanism's minimal representation \n\nmechanism: Mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.input_dimension","page":"API Documentation","title":"Dojo.input_dimension","text":"input_dimension(mechanism) \n\nreturn the number of inputs for mechanism \n\nmechanism: Mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.zero_velocity!","page":"API Documentation","title":"Dojo.zero_velocity!","text":"zero_velocity!(mechanism) \n\nset all mechanism body velocities to zero \n\nmechanism: Mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.root_to_leaves_ordering","page":"API Documentation","title":"Dojo.root_to_leaves_ordering","text":"root_to_leaves_ordering(mechanism; exclude_origin, exclude_loop_joints)\n\nordered list of ids from root to leaves, all nodes are visited a single time\n    excluding: origin, joints forming a loop which are not visited\n\nmechanism: Mechanism \nexclude_origin: flag to exclude origin from traversal \nexclude_loop_joints: flag to exclude loop joints from traversal\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_floating_base","page":"API Documentation","title":"Dojo.set_floating_base","text":"set_floating_base(mechanism, name) \n\nreturns a mechanism with modified joints having body identified with 'name' as the floating base\n\nmechanism: Mechanism \nname: Symbol, identifier for floating-base body\n\n\n\n\n\n","category":"function"},{"location":"api.html#Nodes","page":"API Documentation","title":"Nodes","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Node\nBody\nOrigin\nConstraint\nShape\nEmptyShape\nMesh\nBox\nCylinder\nCapsule\nSphere\nPyramid\nShapes","category":"page"},{"location":"api.html#Dojo.Node","page":"API Documentation","title":"Dojo.Node","text":"Node{T}\n\nAbstract type for graph node object\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Body","page":"API Documentation","title":"Dojo.Body","text":"Body{T} <: Node{T}\n\nA rigid body object\n\nid: unique identifying number \nname: unique identifying name \nmass: inertial property (kilograms)\ninertia: inertia matrix (kilograms meter^2)\nstate: State; representation of the system's: position, linear velocity, orientation, and angular velocity \nshape: Shape; geometry information about the Body\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Origin","page":"API Documentation","title":"Dojo.Origin","text":"Origin{T} <: Node{T}\n\nGlobal reference frame\n\nid: always 0 \nname: always :origin \nstate: State; defaults to zero values\nshape: Shape; defaults to EmptyShape\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Constraint","page":"API Documentation","title":"Dojo.Constraint","text":"Constraint{T}\n\nAbstract type for graph edge object\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Shape","page":"API Documentation","title":"Dojo.Shape","text":"Shape{T} \n\nAbstract type; Subtypes contain geometric and visual information for a Body.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.EmptyShape","page":"API Documentation","title":"Dojo.EmptyShape","text":"EmptyShape{T} <: Shape{T}\n\nContains no geometric or visual information\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Mesh","page":"API Documentation","title":"Dojo.Mesh","text":"Mesh{T} <: Shape{T}\n\nContains geometric and visual information based on .obj file\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Box","page":"API Documentation","title":"Dojo.Box","text":"Box{T} <: Shape{T}\n\nCuboid geometry \n\nposition_offset: geometry origin offset from center of mass\naxis_offset: orientation offset from body frame\nxyz: dimensions (meters)\nscale: scaling\ncolor: RGBA\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Cylinder","page":"API Documentation","title":"Dojo.Cylinder","text":"Cylinder{T} <: Shape{T}\n\ncylinder geometry \n\nposition_offset: geometry origin offset from center of mass\naxis_offset: orientation offset from body frame\nrh: radius and height dimensions (meters)\nscale: scaling\ncolor: RGBA\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Capsule","page":"API Documentation","title":"Dojo.Capsule","text":"Capsule{T} <: Shape{T}\n\ncapsule geometry \n\nposition_offset: geometry origin offset from center of mass\naxis_offset: orientation offset from body frame\nrh: radius and height dimensions (meters)\nscale: scaling\ncolor: RGBA\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Sphere","page":"API Documentation","title":"Dojo.Sphere","text":"Sphere{T} <: Shape{T}\n\nsphere geometry \n\nposition_offset: geometry origin offset from center of mass\naxis_offset: orientation offset from body frame\nr: radius (meters)\nscale: scaling\ncolor: RGBA\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Pyramid","page":"API Documentation","title":"Dojo.Pyramid","text":"Pyramid{T} <: Shape{T}\n\npyramid geometry \n\nposition_offset: geometry origin offset from center of mass\naxis_offset: orientation offset from body frame\nwh: width and height dimensions (meters)\nscale: scaling\ncolor: RGBA\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Shapes","page":"API Documentation","title":"Dojo.Shapes","text":"Shapes{T} <: Shape{T}\n\ncomposite geometry\n\nshape: list of Shape objects\nposition_offset: geometry origin offset from center of mass\naxis_offset: orientation offset from body frame\nxyz: dimensions (meters)\nscale: scaling\ncolor: RGBA\n\n\n\n\n\n","category":"type"},{"location":"api.html#Joints","page":"API Documentation","title":"Joints","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Joint\nRotational\nTranslational\nJointConstraint\nFloating\nFixed\nPrismatic\nPlanar\nFixedOrientation\nRevolute\nCylindrical\nPlanarAxis\nFreeRevolute\nOrbital\nPrismaticOrbital\nPlanarOrbital\nFreeOrbital\nSpherical\nCylindricalFree\nPlanarFree","category":"page"},{"location":"api.html#Dojo.Joint","page":"API Documentation","title":"Dojo.Joint","text":"Joint{T} \n\nAbstract type for 3-dimensional constraint between two Body objects\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Rotational","page":"API Documentation","title":"Dojo.Rotational","text":"Rotational{T} <: Joint{T}\n\nconstraint limiting rotational degrees of freedom\n\naxis: rotation axis in parent offset frame\naxis_mask1: rotation axis mask in pbody's frame\naxis_mask2: rotation axis mask in pbody's frame\naxis_mask3: rotation axis mask in pbody's frame\naxis_offset: rotation axis offset from pbody's frame\nspring :coefficient for joint spring\ndamper: coefficient for joint damper\nspring_offset: nominal joint configuration\njoint_limits: lower and upper limits on the joint configuration\nspring_type: can be :linear or :sinusoidal (currently not implemented), if linear then we need joint_limits to avoid the 360° singularity.\ninput: external impulse torque\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Translational","page":"API Documentation","title":"Dojo.Translational","text":"Translational{T} <: Joint{T}\n\nconstraint limiting translational degrees of freedom\n\naxis: translational axis in parent offset frame\naxis_mask1: translational axis mask in pbody's frame\naxis_mask2: translational axis mask in pbody's frame\naxis_mask3: translational axis mask in pbody's frame\nvertices: points in parent can child frames\nspring: coefficient for joint spring\ndamper: coefficient for joint damper\nspring_offset: nominal joint configuration\njoint_limits: lower and upper limits on the joint configuration\nspring_type: can be :linear or :sinusoidal (currently not implemented), if linear then we need joint_limits to avoid the 360° singularity.\ninput: external impulse force\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.JointConstraint","page":"API Documentation","title":"Dojo.JointConstraint","text":"JointConstraint{T} <: Constraint{T}\n\nconstraint restricting translational and rotational degrees of freedom between two Body objects.\n\nid: a unique identifying number\nname: a unique identifying name\ntranslational: Translational\nrotational: Rotational\nspring: flag for joint springs on\ndamper: flag for joint dampers on\nparent_id: identifying number for parent Body{T}\nchild_id: identifying number for child Body{T}\nminimal_index: indices for minimal coordinates\nimpulses: joint impulses that maintain constraint between two Body{T} objects\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Floating","page":"API Documentation","title":"Dojo.Floating","text":"Floating{T} <: JointConstraint{T} \n\nno restricted degrees of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.Fixed","page":"API Documentation","title":"Dojo.Fixed","text":"Fixed{T} <: JointConstraint{T}\n\nfixed connection between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.Prismatic","page":"API Documentation","title":"Dojo.Prismatic","text":"Prismatic{T} <: JointConstraint{T}\n\none translational degree of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.Planar","page":"API Documentation","title":"Dojo.Planar","text":"Planar{T} <: JointConstraint{T} \n\ntwo translational degree of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.FixedOrientation","page":"API Documentation","title":"Dojo.FixedOrientation","text":"FixedOrientation{T} <: JointConstraint{T} \n\nthree translational degree of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.Revolute","page":"API Documentation","title":"Dojo.Revolute","text":"Revolute{T} <: JointConstraint{T} \n\none rotational degree of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.Cylindrical","page":"API Documentation","title":"Dojo.Cylindrical","text":"Cylindrical{T} <: JointConstraint{T} \n\none translational and one rotational degree of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.PlanarAxis","page":"API Documentation","title":"Dojo.PlanarAxis","text":"PlanarAxis{T} <: JointConstraint{T} \n\ntwo translational and one rotational degree of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.FreeRevolute","page":"API Documentation","title":"Dojo.FreeRevolute","text":"FreeRevolute{T} <: JointConstraint{T} \n\nfree translation with rotation along one axis\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.Orbital","page":"API Documentation","title":"Dojo.Orbital","text":"Orbital{T} <: JointConstraint{T} \n\ntwo rotational degrees of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.PrismaticOrbital","page":"API Documentation","title":"Dojo.PrismaticOrbital","text":"PrismaticOrbital{T} <: JointConstraint{T} \n\none translational and two rotational degrees of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.PlanarOrbital","page":"API Documentation","title":"Dojo.PlanarOrbital","text":"PlanarOrbital{T} <: JointConstraint{T} \n\ntwo translational and two rotational degrees of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.FreeOrbital","page":"API Documentation","title":"Dojo.FreeOrbital","text":"FreeOrbital{T} <: JointConstraint{T} \n\nthree translational and two rotational degrees of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.Spherical","page":"API Documentation","title":"Dojo.Spherical","text":"Spherical{T} <: JointConstraint{T} \n\nthree rotational degrees of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.CylindricalFree","page":"API Documentation","title":"Dojo.CylindricalFree","text":"CylindricalFree{T} <: JointConstraint{T} \n\none translational and three rotational degrees of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.PlanarFree","page":"API Documentation","title":"Dojo.PlanarFree","text":"PlanarFree{T} <: JointConstraint{T} \n\ntwo translational and three rotational degrees of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Contacts","page":"API Documentation","title":"Contacts","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Contact\nImpactContact\nLinearContact\nNonlinearContact\nContactConstraint\ncontact_constraint\ncontact_location\nget_sdf ","category":"page"},{"location":"api.html#Dojo.Contact","page":"API Documentation","title":"Dojo.Contact","text":"Contact{T,N} \n\nAbstract type containing contact information associated with Body objects.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.ImpactContact","page":"API Documentation","title":"Dojo.ImpactContact","text":"ImpactContact{T,N} <: Contact{T,N}\n\ncontact object for impact (i.e., no friction)\n\ncollision: Collision\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.LinearContact","page":"API Documentation","title":"Dojo.LinearContact","text":"LinearContact{T,N} <: Contact{T,N}\n\ncontact object for impact and friction with a linearized friction cone\n\nfriction_coefficient: value of friction coefficient\ncollision: Collision\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.NonlinearContact","page":"API Documentation","title":"Dojo.NonlinearContact","text":"NonlinearContact{T,N} <: Contact{T,N}\n\ncontact object for impact and friction with a nonlinear friction cone\n\nfriction_coefficient: value of friction coefficient\ncontact_tangent: mapping from world frame to surface tangent frame \ncontact_normal: inverse/complement of contact_tangent\ncontact_origin: position of contact on Body relative to center of mass \ncontact radius: radius of contact\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.ContactConstraint","page":"API Documentation","title":"Dojo.ContactConstraint","text":"ContactConstraint{T} <: Constraint{T}\n\nconstraint containing information for contact node.\n\nid: unique identifying number \nname: unique identifying name \nmodel: type of contact model: ImpactContact, LinearContact, NonlinearContact \nparent_id: identifying number of Body experiencing contact \nchild_id: always 0\nimpulses: contact impulses applied to Body \nimpulses_dual: dual contact impulses, used by solver to enforce correct contact behaviors\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.contact_constraint","page":"API Documentation","title":"Dojo.contact_constraint","text":"contact_constraint(bodies::Vector{Body}) \n\ngenerate ContactConstraints for each Body in list\n\nnormal: surface normal for each contact point\nfriction coefficient: value of coefficient of friction for each contact point (optional for ImpactContact)\ncontact_origins: the offset with respect to the center of Body for each contact point (optional)\ncontact_radius: radius for each contact (optional)\ncontact_type: :nonlinear, :linear, :impact\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.contact_location","page":"API Documentation","title":"Dojo.contact_location","text":"contact_location(contact, x, q) \n\nlocation of contact point in world coordinates \n\ncontact: ContactConstraint \nx: body position \nq: body orientation\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_sdf","page":"API Documentation","title":"Dojo.get_sdf","text":"get_sdf(contact, x, q) \n\nreturns the signed distance for a contact\n\ncontact: ContactConstraint\nx: body position \nq: body orientation\n\n\n\n\n\n","category":"function"},{"location":"api.html#Representations","page":"API Documentation","title":"Representations","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"State\nminimal_to_maximal\nmaximal_to_minimal","category":"page"},{"location":"api.html#Dojo.State","page":"API Documentation","title":"Dojo.State","text":"State{T} \n\nstate information in maximal coordinates for Body at time steps: 1, 2, 3. \ninformation at time step 3 is recovered using configurations at time step 2 and velocities at time step 2.5.\n\nx1: position at previous time step\nq1: orientation (Quaternion) at previous time step \nv15: linear velocity at time step 1.5 (midpoint)\nϕ15: angular velocity at time step 1.5 (midpoint)\n\nx2: position at current time step \nq2: orientation (Quaternion) at current time step \nF2: linear impulse (force * time step) applied at current time step \nτ2: angular impulse (torque * timestep) applied at current time step \n\nvsol: linear velocity at time step 2.5 (midpoint); contains current value (index 1) and candidate value (index 2)\nϕsol: angular velocity at time step 2.5 (midpoint); contains current value (index 1) and candidate value (index 2)\n\nd: implicit dynamics evaluator (zero vector indicates physics are satisfied)\nD: Jacobian of implicit dynamics\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.minimal_to_maximal","page":"API Documentation","title":"Dojo.minimal_to_maximal","text":"minimal_to_maximal(mechanism, y) \n\nconvert minimal to maximal representation\n\nmechanism: Mechanism \ny: minimal state\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.maximal_to_minimal","page":"API Documentation","title":"Dojo.maximal_to_minimal","text":"maximal_to_minimal(mechanism, z)\n\nconvert maximal to minimal representation\n\nmechanism: Mechanism \nz: maximal state\n\n\n\n\n\n","category":"function"},{"location":"api.html#Mechanics","page":"API Documentation","title":"Mechanics","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"mechanical_energy \nkinetic_energy \npotential_energy \nmomentum","category":"page"},{"location":"api.html#Dojo.mechanical_energy","page":"API Documentation","title":"Dojo.mechanical_energy","text":"mechanical_energy(mechanism, storage)\n\nmechanism's total mechanical energy\n\nmechanism: Mechanism \nstorage: Storage\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.kinetic_energy","page":"API Documentation","title":"Dojo.kinetic_energy","text":"kinetic_energy(mechanism, storage)\n\nmechanism's kinetic energy from linear and angular velocity\n\nmechanism: Mechanism \nstorage: Storage\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.potential_energy","page":"API Documentation","title":"Dojo.potential_energy","text":"potential_energy(mechanism, storage)\n\nmechanism's potential energy from gravity and springs\n\nmechanism: Mechanism \nstorage: Storage\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.momentum","page":"API Documentation","title":"Dojo.momentum","text":"momentum(mechanism, storage) \n\nmechanism's linear and angular momentum \n\nmechanism: Mechanism \nstorage: Storage\n\n\n\n\n\n","category":"function"},{"location":"api.html#Graph","page":"API Documentation","title":"Graph","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"System\nEntry\nfull_matrix \nfull_vector","category":"page"},{"location":"api.html#Dojo.System","page":"API Documentation","title":"Dojo.System","text":"System{N}\n\ngraph structure representing a linear system (\"Ax = b\")\n\nmatrix_entries: matrix entries\nvector_entries: residual entries \ndiagonal_inverses: matrix inverses computed during LU factorization\nacyclic_children: contains direct children that are not part of a cycle\ncyclic_children: contains direct and indirect children that are part of a cycle\nparents: contains direct and cycle-opening parents\ndfs_list: list of graph nodes (depth first)\ngraph: graph object\ndfs_graph: direct graph object\ndimrow: dimensions of row\ndimcol: dimensions of columns\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Entry","page":"API Documentation","title":"Dojo.Entry","text":"Entry{ET}\n\nvalue: data \nisinverted: flag indicating if matrix value has been inverted\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.full_matrix","page":"API Documentation","title":"Dojo.full_matrix","text":"full_matrix(system) \n\nreturns matrix from a simulation step's linear system (i.e., A from \"Ax = b\")\n\nsystem: System\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.full_vector","page":"API Documentation","title":"Dojo.full_vector","text":"full_vector(system) \n\nreturns residual vector from a simulation step's linear system (i.e., b from \"Ax = b\")\n\nsystem: System\n\n\n\n\n\n","category":"function"},{"location":"api.html#Environments","page":"API Documentation","title":"Environments","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Environment\nAnt\nAtlas\nBlock\nCartpole\nHalfCheetah\nHopper\nPendulum\nQuadruped\nRaibertHopper\nRexHopper\nWalker\nget_environment\nstep\nget_observation\ncost\nis_done\nreset\ndynamics\ndynamics_jacobian_state \ndynamics_jacobian_input\nSpace\nBoxSpace","category":"page"},{"location":"api.html#Dojo.Environment","page":"API Documentation","title":"Dojo.Environment","text":"Environment{T} \n\nsimulation object containing a mechanism along with additional information useful for \nreinforcement learning and trajectory optimization \n\nmechanism: Mechanism\nrepresentation: :minimal or :maximal state representation\ninput_space: Space, limits on inputs\nobservation_space: Space, limits on observations\nstate: contains current minimal or maximal states\ndynamics_jacobian_state: dynamics Jacobian wrt to state\ndynamics_jacobian_input: dynamics Jacobian wrt to input\ninput_previous: input applied to mechanism at previous time step\ncontrol_map: mapping for inputs to mechanism translational and rotational dynamics\nnum_states: dimension of minimal or maximal state\nnum_inputs: dimension of inputs\nnum_observations: dimension of observation\ninfo: object containing environment specific information\nrng: random number generator\nvis: Visualizer\nopts_step: SolverOptions\nopts_grad: SolverOptions\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Ant","page":"API Documentation","title":"Dojo.Ant","text":"Ant <: Environment\n\nfour-legged insect-like robot, based on https://gym.openai.com/envs/Ant-v2/\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Atlas","page":"API Documentation","title":"Dojo.Atlas","text":"Atlas <: Environment\n\nhumanoid robot designed by Boston Dynamics (v5)\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Block","page":"API Documentation","title":"Dojo.Block","text":"Block\n\nrigid body with fully actuation\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Cartpole","page":"API Documentation","title":"Dojo.Cartpole","text":"Cartpole <: Environment\n\nclassic system with one translational (cart) and one rotational (pole) degree of freedom\nhttps://underactuated.mit.edu/acrobot.html#cart_pole\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.HalfCheetah","page":"API Documentation","title":"Dojo.HalfCheetah","text":"HalfCheetah <: Environment\n\nplanar cheetah-like robot, based on https://gym.openai.com/envs/HalfCheetah-v2/\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Hopper","page":"API Documentation","title":"Dojo.Hopper","text":"Hopper <: Environment\n\nplanar hopping robot, based on https://gym.openai.com/envs/Hopper-v2/\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Pendulum","page":"API Documentation","title":"Dojo.Pendulum","text":"Pendulum <: Environment\n\nclassic system with one rotational degree of freedom\nhttps://underactuated.mit.edu/pend.html\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Quadruped","page":"API Documentation","title":"Dojo.Quadruped","text":"Quadruped <: Environment\n\nfour-legged dog-like robot \nhttps://www.unitree.com/products/a1/\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.RaibertHopper","page":"API Documentation","title":"Dojo.RaibertHopper","text":"RaibertHopper <: Environment\n\nhopping robot, inspired by: \"Dynamically Stable Legged Locomotion\"\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.RexHopper","page":"API Documentation","title":"Dojo.RexHopper","text":"RexHopper <: Environment\n\nhopping robot designed and build by the Robotic Exploration Lab (Benjamin Bokser)\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Walker","page":"API Documentation","title":"Dojo.Walker","text":"Walker <: Environment\n\nplanar bipedal robot, based on: https://gym.openai.com/envs/Walker2d-v2/\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.get_environment","page":"API Documentation","title":"Dojo.get_environment","text":"get_environment(model; kwargs...)\n\nconstruct existing environment \n\nmodel: name of of environment \nkwargs: environment specific parameters\n\n\n\n\n\n","category":"function"},{"location":"api.html#Base.step","page":"API Documentation","title":"Base.step","text":"step(env, x, u; gradients, attitude_decompress)\n\nsimulates environment one time step \n\nenv: Environment \nx: state \nu: input \ngradients: flag for computing gradients of dynamics\nattitude_decompress: flag for pre- and post-concatenating Jacobians with attitude Jacobians\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_observation","page":"API Documentation","title":"Dojo.get_observation","text":"get_observation(env) \n\nreturn observation for current state \n\nenv: Environment\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.cost","page":"API Documentation","title":"Dojo.cost","text":"cost(env, x, u) \n\nreturn cost (-reward) for current state and input\n\nenv: Environment\nx: state \nu: input\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.is_done","page":"API Documentation","title":"Dojo.is_done","text":"is_done(env) \n\ncheck for termination of simulation\n\nenv: Environment\n\n\n\n\n\n","category":"function"},{"location":"api.html#Base.reset","page":"API Documentation","title":"Base.reset","text":"reset(env; x) \n\nreturns environment to nominal state\n\nenv: Environment\nx: state\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.dynamics","page":"API Documentation","title":"Dojo.dynamics","text":"dynamics(y, env, x, u, w)\n\nevaluates an environment's dynamics (in-place)\n\ny: state at next time step \nenv: Environment \nx: state at current time step \nu: input \nw: system parameters\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.dynamics_jacobian_state","page":"API Documentation","title":"Dojo.dynamics_jacobian_state","text":"dynamics_jacobian_state(dx, env, x, u, w)\n\nevaluates an environment's dynamics Jacobian wrt state (in-place)\n\ndx: state Jacobian at next time step \nenv: Environment \nx: state at current time step \nu: input \nw: system parameters\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.dynamics_jacobian_input","page":"API Documentation","title":"Dojo.dynamics_jacobian_input","text":"dynamics_jacobian_input(du, env, x, u, w)\n\nevaluates an environment's dynamics Jacobian wrt input (in-place)\n\ndu: input Jacobian at next time step \nenv: Environment \nx: state at current time step \nu: input \nw: system parameters\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.Space","page":"API Documentation","title":"Dojo.Space","text":"Space{T,N} \n\nAbstract type for domains\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.BoxSpace","page":"API Documentation","title":"Dojo.BoxSpace","text":"BoxSpace{T,N} <: Environment{T,N}\n\ndomain with lower and upper limits \n\nn: dimension of domain \nlow:: lower limit \nhigh: upper limit \nshape: tuple (n,)\ndtype: type for domain\n\n\n\n\n\n","category":"type"},{"location":"api.html#Simulate","page":"API Documentation","title":"Simulate","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Storage\nstep!\nsimulate!","category":"page"},{"location":"api.html#Dojo.Storage","page":"API Documentation","title":"Dojo.Storage","text":"Storage{T,N}\n\ncontains maximal-representation trajectories\n\nx: position \nq: orientation (Quaternion)\nv: linear velocity (midpoint) \nω: angular velocity (midpoint)\npx: linear momentum\npq: angular momentum \nvl: linear velocity\nωl: angular velocity\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.step!","page":"API Documentation","title":"Dojo.step!","text":"step!(mechanism::Mechanism{T}, z::Vector{T}, u::Vector{T}; opts)\n\nsimulate mechanism for one time step\n\nmechanism: Mechanism\nz: maximal state \nu: inputs\nopts: SolverOptions\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.simulate!","page":"API Documentation","title":"Dojo.simulate!","text":"simulate!(mechanism, steps, storage, control!;\n    record, verbose, abort_upon_failure, opts)\n\nsimulate a mechanism\n\nmechanism: Mechanism \nsteps: range of steps to simulate \nstorage: Storage\ncontrol!: Function setting inputs for mechanism\nrecord: flag for recording simulation to storage\nverbose: flag for printing during simulation \nabort_upon_failure: flag for terminating simulation is solver fails to meet tolerances\nopts: SolverOptions\n\n\n\n\n\n","category":"function"},{"location":"api.html#Gradients","page":"API Documentation","title":"Gradients","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"get_maximal_gradients!\nget_minimal_gradients!\nmaximal_to_minimal_jacobian\nminimal_to_maximal_jacobian","category":"page"},{"location":"api.html#Dojo.get_maximal_gradients!","page":"API Documentation","title":"Dojo.get_maximal_gradients!","text":"get_maximal_gradients!(mechanism, z, u; opts) \n\nreturn maximal gradients for mechanism \nnote: this requires simulating the mechanism for one time step\n\nmechanism: Mechanism\nz: state \nu: input\nopts: SolverOptions\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_minimal_gradients!","page":"API Documentation","title":"Dojo.get_minimal_gradients!","text":"get_minimal_gradients!(mechanism, y, u; opts) \n\nreturn minimal gradients for mechanism \nnote: this requires simulating the mechanism for one time step\n\nmechanism: Mechanism\ny: state \nu: input\nopts: SolverOptions\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.maximal_to_minimal_jacobian","page":"API Documentation","title":"Dojo.maximal_to_minimal_jacobian","text":"maximal_to_minimal_jacobian(mechanism, z)\n\nJacobian of mapping from maximal to minimal representation\n\nmechanism: Mechanism \nz: maximal state\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.minimal_to_maximal_jacobian","page":"API Documentation","title":"Dojo.minimal_to_maximal_jacobian","text":"minimal_to_maximal_jacobian(mechanism, y)\n\nJacobian of mapping from minimal to maximal representation\n\nmechanism: Mechanism \ny: minimal state\n\n\n\n\n\n","category":"function"},{"location":"api.html#Solver","page":"API Documentation","title":"Solver","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"SolverOptions\nmehrotra!","category":"page"},{"location":"api.html#Dojo.SolverOptions","page":"API Documentation","title":"Dojo.SolverOptions","text":"SolverOptions{T}\n\nOptions and tolerances of primal-dual interior point solver.\n\nrtol: tolerance on residual violations (equality constraints); defaults to 1e-6\nbtol: tolerance on bilinear violations (complementarity constraints); defaults to 1e-3\nls_scale: line search scaling factor (α_new ← ls_scale * α_current); defaults to 0.5\nmax_iter: maximum number of Newton iterations; defaults to 50\nmax_ls: maximum number of line search steps; defaults to 10\nundercut: complementarity slackness target; solver will aim at reaching complementarity violation = btol / undercut; defaults to Inf\nno_progress_max: number of Newton's iterations without progress trigerring the rescaling of the target complementarity violation; defaults to 3\nno_progress_undercut: undercut scaling factor (target_new ← target_current / no_progress_undercut); defaults to 10\nverbose: flag for printing the status of the solver during the solve; defaults to false\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.mehrotra!","page":"API Documentation","title":"Dojo.mehrotra!","text":"mehrotra!(mechanism; opts)\n\ninterior-point solver for simulation-step feasibility problem\n\nmechanism: Mechanism\nopts: SolverOptions\n\n\n\n\n\n","category":"function"},{"location":"api.html#Visualization","page":"API Documentation","title":"Visualization","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"visualize\nbuild_robot\nset_robot\nset_camera!\nset_light!\nset_surface!\nset_floor!","category":"page"},{"location":"api.html#Dojo.visualize","page":"API Documentation","title":"Dojo.visualize","text":"visualize(mechanism, storage; vis, build, show_contact, animation, color, name)\n\nvisualize mechanism using trajectory from storage \n\nmechanism: Mechanism \nstorage: Storage \nvis: Visualizer \nbuild: flag to construct mechanism visuals (only needs to be built once)\nshow_contact: flag to show contact locations on system \ncolor: RGBA \nname: unique identifier for mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.build_robot","page":"API Documentation","title":"Dojo.build_robot","text":"build_robot(mechanism; vis, show_contact, name, color)\n\nconstruct visuals for mechanism \n\nmechanism: Mechanism \nvis: Visualizer \nshow_contact: flag to show contact locations on mechanism \nname: unique identifier \ncolor: RGBA\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_robot","page":"API Documentation","title":"Dojo.set_robot","text":"set_robot(vis, mechanism, z; show_contact, name)\n\nvisualze mechanism configuration from maximal representation \n\nvis: Visualizer \nmechanism: Mechanism \nz: maximal state \nshow_contact: flag to show contact locations on mechanism \nname: unique identifier\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_camera!","page":"API Documentation","title":"Dojo.set_camera!","text":"set_camera!(vis; zoom, cam_pos)\n\nposition and zoom for camera in visualization\n\nvis: Visualizer\nzoom: value for zoom\ncam_pos: position of camera\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_light!","page":"API Documentation","title":"Dojo.set_light!","text":"set_light!(vis; ambient, fill, pointX, pointXshadow, direction)\n\nlighting conditions for visualization\n\nvis: Visualizer\nambient: value for ambient lighting\ndirection: positive or negative direction for light\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_surface!","page":"API Documentation","title":"Dojo.set_surface!","text":"set_surface!(vis; f, xlims, ylims, color, n)\n\nadds surface to visualization\n\nvis::Visualizer\nf: implicit function representing surface\nxlims: lateral domain for surface\nylims: longitudinal domain for surface\ncolor: RGBA\nn: number of discretization points along each domain\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_floor!","page":"API Documentation","title":"Dojo.set_floor!","text":"set_floor!(vis; x, y, z, origin, normal, color, tilepermeter, imagename, axis, grid)\n\nadds floor to visualization\n\nvis::Visualizer\nx: lateral position\ny: longitudinal position\nz: vertical position\norigin:: position of the center of the floor\nnormal:: unit vector indicating the normal to the floor\ncolor: RGBA\ntilepermeter: scaling\nimagename: path to image\naxis: flag to turn on visualizer axis\ngrid: flag to turn on visualizer grid\n\n\n\n\n\n","category":"function"},{"location":"define_simulation.html#Defining-a-Simulation","page":"Defining a Simulation","title":"Defining a Simulation","text":"","category":"section"},{"location":"define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"Here, we explain how to simulate a dynamical system i.e., a Mechanism forward in time. The example that we are trying to replicate the Dzhanibekov effect shown below.","category":"page"},{"location":"define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"(Image: dzhanibekov)","category":"page"},{"location":"define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"Load the Dojo package.","category":"page"},{"location":"define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"using Dojo","category":"page"},{"location":"define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"Define the simulation time step, and other parameters like the gravity.","category":"page"},{"location":"define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"timestep=0.01\ngravity=0.0","category":"page"},{"location":"define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"We use the mechanism called :dzhanibekov.","category":"page"},{"location":"define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"mech = get_mechanism(:dzhanibekov,\n        timestep=timestep,\n        gravity=gravity);","category":"page"},{"location":"define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"We initialize the system with a given initial angular velocity.","category":"page"},{"location":"define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"initialize!(mech, :dzhanibekov,\n    angular_velocity=[15.0; 0.01; 0.0])","category":"page"},{"location":"define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"We simulate this system for 5 seconds, we record the resulting trajectory in storage,","category":"page"},{"location":"define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"storage = simulate!(mech, 5.0,\n    record=true,\n    verbose=false)","category":"page"},{"location":"define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"We visualize the trajectory in the browser,","category":"page"},{"location":"define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"vis = Visualizer()\nopen(vis)\nvisualize(mech, storage, vis=vis)","category":"page"},{"location":"define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"And voila! You should see something like this;","category":"page"},{"location":"define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"<img src=\"./assets/animations/dzhanibekov.gif\" width=\"300\"/>","category":"page"},{"location":"simulation.html#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"simulation.html","page":"Simulation","title":"Simulation","text":"Dojo can simulate a number of interesting physical behaviors.  We include notebooks (generated upon installation) for the examples below.","category":"page"},{"location":"simulation.html#[Atlas-Drop](https://github.com/dojo-sim/Dojo.jl/blob/main/examples/simulation/atlas_drop.jl)","page":"Simulation","title":"Atlas Drop","text":"","category":"section"},{"location":"simulation.html","page":"Simulation","title":"Simulation","text":"<img src=\"./assets/animations/atlas_drop.gif\" width=\"100\"/>","category":"page"},{"location":"simulation.html","page":"Simulation","title":"Simulation","text":"The humanoid Atlas is dropped onto a flat surface.  Dojo is able to simulate hard contact and prevent interpenetration of the robot's feet with the floor. In comparison, when the same system is simulated in MuJoCo, centimeters of interpenetration occur.","category":"page"},{"location":"simulation.html#[Friction-Cone-Comparison](https://github.com/dojo-sim/Dojo.jl/blob/main/examples/simulation/cone_compare.jl)","page":"Simulation","title":"Friction Cone Comparison","text":"","category":"section"},{"location":"simulation.html","page":"Simulation","title":"Simulation","text":"<img src=\"./assets/animations/cone_compare_mujoco.gif\" width=\"300\"/>","category":"page"},{"location":"simulation.html","page":"Simulation","title":"Simulation","text":"Blocks are simulated with initial velocity before impacting and sliding along a flat surface. We compare Dojo's nonlinear cone (blue) with a linearized approximation (orange) and MuJoCo's default linear cone (magenta). The linearized cones exhibit drift due to the approximation, whereas Dojo's nonlinear cone produces the expected sliding behavior.","category":"page"},{"location":"simulation.html#[Dzhanibekov-Effect](https://github.com/dojo-sim/Dojo.jl/blob/main/examples/simulation/dzhanibekov.jl)","page":"Simulation","title":"Dzhanibekov Effect","text":"","category":"section"},{"location":"simulation.html","page":"Simulation","title":"Simulation","text":"<img src=\"./assets/animations/dzhanibekov.gif\" width=\"150\"/>","category":"page"},{"location":"simulation.html","page":"Simulation","title":"Simulation","text":"Dojo simulates the unstable rotational motion of a rigid body about its second primary moment of inertia. Using non-Euclidean optimization for quaternions enables continuous simulation of rotating objects without singularity issues.","category":"page"},{"location":"simulation.html#[Tippetop](https://github.com/dojo-sim/Dojo.jl/blob/main/examples/simulation/tippetop.jl)","page":"Simulation","title":"Tippetop","text":"","category":"section"},{"location":"simulation.html","page":"Simulation","title":"Simulation","text":"<img src=\"./assets/animations/tippetop.gif\" width=\"300\"/>","category":"page"},{"location":"simulation.html","page":"Simulation","title":"Simulation","text":"A spinning object osciallates between up and down configurations as a result of its mass distribution.","category":"page"},{"location":"load_environment.html#Load-Existing-Environment","page":"Load Existing Environment","title":"Load Existing Environment","text":"","category":"section"},{"location":"load_environment.html","page":"Load Existing Environment","title":"Load Existing Environment","text":"Dojo includes a number of existing environments: ","category":"page"},{"location":"load_environment.html","page":"Load Existing Environment","title":"Load Existing Environment","text":"Dojo.Ant\nDojo.Atlas\nDojo.Cartpole\nDojo.HalfCheetah\nDojo.Hopper\nDojo.Pendulum\nDojo.Quadruped\nDojo.RaibertHopper\nDojo.RexHopper\nDojo.Walker","category":"page"},{"location":"load_environment.html","page":"Load Existing Environment","title":"Load Existing Environment","text":"Specific environments can be instantiated, for example Dojo.Atlas:","category":"page"},{"location":"load_environment.html","page":"Load Existing Environment","title":"Load Existing Environment","text":"env = get_environment(:atlas)","category":"page"},{"location":"interior_point.html#Algorithm","page":"Algorithm","title":"Algorithm","text":"","category":"section"},{"location":"interior_point.html#Overview","page":"Algorithm","title":"Overview","text":"","category":"section"},{"location":"interior_point.html","page":"Algorithm","title":"Algorithm","text":"To simulate the system forward in time, we need to solve a Nonlinear Complementarity Problem (NCP) at each time step. To efficiently and reliably satisfy the NCP, we developed a custom primal-dual interior-point solver for NCPs with cone constraints and quaternions. The algorithm is largely based upon Mehrotra's predictor-coorector algorithm, while borrowing practical numerical features from CVXOPT to handle cones and non-Euclidean optimization to handle quaternions. We also introduce heuristics that further improve reliability and overall performance of the solver for our simulation-step NCPs.","category":"page"},{"location":"interior_point.html","page":"Algorithm","title":"Algorithm","text":"The primary advantages of this algorithm are the correction to the classic Newton step, which can greatly reduce the iterations required by the solver (often halving the total number of iterations), and feedback on the problem's central-path parameter that helps avoid premature ill-conditioning and adaptively drives the complementarity violation to zero in order to reliably simulate hard contact.","category":"page"},{"location":"interior_point.html#Problem-formulation","page":"Algorithm","title":"Problem formulation","text":"","category":"section"},{"location":"interior_point.html","page":"Algorithm","title":"Algorithm","text":"The solver aims to satisfy instantiations of the following problem:","category":"page"},{"location":"interior_point.html","page":"Algorithm","title":"Algorithm","text":"beginalign*\ntextfind  quad  x y z \ntextsubject to  quad  c(x y z theta) = 0 \n quad y^(i) circ z^(i) = kappa mathbfe  quad i = 1dotsn \n quad y^(i) z^(i) in mathcalK  quad i = 1dots n\nendalign*","category":"page"},{"location":"interior_point.html","page":"Algorithm","title":"Algorithm","text":"with decision variables x in mathbfR^k and y z in mathbfR^m, equality-constraint set c  mathbfR^k times mathbfR^m times mathbfR^m times mathbfR^l rightarrow mathbfR^h, problem data theta in mathbfR^l; and where mathcalK is the Cartesian product of n total positive-orthant and second-order cones. The variables are partitioned: x = (x^(1) dots x^(p)), where i = 1 are Euclidean variables and i = 2 dots p are each quaternion variables; and y = (y^(1) dots y^(n)), z = (z^(1) dots z^(n)), where j = 1 is the positive-orthant and the remaining j = 2 dots n are second-order cones. For convenience, we denote w = (x y z).","category":"page"},{"location":"interior_point.html","page":"Algorithm","title":"Algorithm","text":"The algorithm aims to satisfy a sequence of relaxed problems with kappa  0 and kappa rightarrow 0 in order to reliably converge to a solution of the original problem (i.e., kappa = 0). This continuation approach helps avoid premature ill-conditioning and is the basis for numerous convex and non-convex general-purpose interior-point solvers.","category":"page"},{"location":"interior_point.html#Violation-metrics:","page":"Algorithm","title":"Violation metrics:","text":"","category":"section"},{"location":"interior_point.html","page":"Algorithm","title":"Algorithm","text":"Two metrics are used to measure progress: The constraint violation,","category":"page"},{"location":"interior_point.html","page":"Algorithm","title":"Algorithm","text":"r_textvio =  c(w theta) _infty","category":"page"},{"location":"interior_point.html","page":"Algorithm","title":"Algorithm","text":"and complementarity violation,","category":"page"},{"location":"interior_point.html","page":"Algorithm","title":"Algorithm","text":"b_textvio = textmax_i  y^(i) circ z^(i) _infty","category":"page"},{"location":"interior_point.html","page":"Algorithm","title":"Algorithm","text":"The NCP is considered solved when r_textvio  r_texttol and b_textvio  b_texttol.","category":"page"},{"location":"interior_point.html","page":"Algorithm","title":"Algorithm","text":"info: solver options\nBoth r_tol and b_tol are options that can easily be accessed and modified via SolverOptions.","category":"page"},{"location":"interior_point.html#Newton-Steps","page":"Algorithm","title":"Newton Steps","text":"","category":"section"},{"location":"interior_point.html","page":"Algorithm","title":"Algorithm","text":"The main loop of the solver performs Newton's method on the equality-constraint set c and the bilinear constraints. The solver typically converges in about 10 iterations.","category":"page"},{"location":"interior_point.html","page":"Algorithm","title":"Algorithm","text":"info: solver options\nThe maximal number of Newton's iterations max_iter can be set via SolverOptions.","category":"page"},{"location":"interior_point.html#Line-Search","page":"Algorithm","title":"Line Search","text":"","category":"section"},{"location":"interior_point.html","page":"Algorithm","title":"Algorithm","text":"Newton's method provides a search direction, then we perform a line search along this direction to detemine the step length alpha. We use a backtracking line search that accepts the step whenever it decreases c_textvio or b_textvio. The line search starts with a step alpha=1, if the step acceptance conditions are not met the step is decreased geometrically: alpha leftarrow s cdot alpha. The line search takes at most max_ls backtracking steps.","category":"page"},{"location":"interior_point.html","page":"Algorithm","title":"Algorithm","text":"info: solver options\nThe scaling parameter s is called ls_scale and the maximum number of line search iteration max_ls can be set via SolverOptions.","category":"page"},{"location":"linearized_friction.html#Linearized-Friction","page":"Linearized Friction","title":"Linearized Friction","text":"","category":"section"},{"location":"linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"Coulomb friction instantaneously maximizes the dissipation of kinetic energy between two objects in contact.","category":"page"},{"location":"linearized_friction.html#Mathematical-Model","page":"Linearized Friction","title":"Mathematical Model","text":"","category":"section"},{"location":"linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"For a single contact point, this physical phenomenon can be modeled by the following optimization problem,","category":"page"},{"location":"linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"beginalign*\nundersetbtextminimize  quad v^T b \ntextsubject to    quad b_2 leq mu gamma\nendalign*","category":"page"},{"location":"linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"where v in mathbfR^2 is the tangential velocity at the contact point, b in mathbfR^2 is the friction force, and mu in mathbfR_+ is the coefficient of friction between the two objects.","category":"page"},{"location":"linearized_friction.html#Linearized-Model","page":"Linearized Friction","title":"Linearized Model","text":"","category":"section"},{"location":"linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"This above problem is naturally a convex second-order cone program, and can be efficiently and reliably solved. However, classically, an approximate version:","category":"page"},{"location":"linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"beginalign*\nundersetbetatextminimize  quad v^T  -v^T beta \ntextsubject to        quad beta^T mathbf1 leq mu gamma \n                         quad beta geq 0\nendalign*","category":"page"},{"location":"linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"which satisfies the LCP formulation, is instead solved. Here, the friction cone is linearized and the friction vector, beta in mathbfR^4, is correspondingly overparameterized and subject to additional non-negative constraints.","category":"page"},{"location":"linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"The optimality conditions of the above problem and constraints used in the LCP are:","category":"page"},{"location":"linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"beginalign*\nv^T  -v^T^T + psi mathbf1 - eta = 0 \nmu gamma -beta^T textbf1  geq 0\npsi cdot (mu gamma - beta^T textbf1) = 0 \nbeta circ eta = 0 \nbeta psi eta geq 0\nendalign*","category":"page"},{"location":"linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"where psi in mathbfR and eta in mathbfR^4 are the dual variables associated with the friction cone and positivity constraints, respectively, and textbf1 is a vector of ones.","category":"page"},{"location":"system_identification.html#System-Identification","page":"System Identification","title":"System Identification","text":"","category":"section"},{"location":"system_identification.html","page":"System Identification","title":"System Identification","text":"A real-world dataset is used to learn the geometric and friction properties of a block being tossed onto a flat surface. Gradient-based optimization is employed to regress parameters and real-to-sim validation is performed. The ground truth system is shown in orange and the learned system in blue.","category":"page"},{"location":"system_identification.html#Geometry","page":"System Identification","title":"Geometry","text":"","category":"section"},{"location":"system_identification.html","page":"System Identification","title":"System Identification","text":"<img src=\"./assets/animations/box_learning.gif\" width=\"300\"/>","category":"page"},{"location":"system_identification.html","page":"System Identification","title":"System Identification","text":"The eight locations of the block's corners relative to its center of mass are learned.","category":"page"},{"location":"system_identification.html#Friction","page":"System Identification","title":"Friction","text":"","category":"section"},{"location":"system_identification.html","page":"System Identification","title":"System Identification","text":"<img src=\"./assets/animations/cone_learning.gif\" width=\"200\"/>","category":"page"},{"location":"system_identification.html","page":"System Identification","title":"System Identification","text":"A friction coefficient, describing a friction cone, is learned for all of the contact points.","category":"page"},{"location":"system_identification.html#Real-To-Sim","page":"System Identification","title":"Real-To-Sim","text":"","category":"section"},{"location":"system_identification.html","page":"System Identification","title":"System Identification","text":"<img src=\"./assets/animations/box_toss.gif\" width=\"300\"/>","category":"page"},{"location":"system_identification.html","page":"System Identification","title":"System Identification","text":"The system parameters are learned to within a pm 5  error from their ground-truth values. These parameters are then compared to the ground-truth system in simulation.","category":"page"},{"location":"system_identification.html#Learning","page":"System Identification","title":"Learning","text":"","category":"section"},{"location":"system_identification.html","page":"System Identification","title":"System Identification","text":"The cost function: ","category":"page"},{"location":"system_identification.html","page":"System Identification","title":"System Identification","text":"mathcalL(mathcalD theta) = sum_Z in mathcalD L(Z theta) = sum_Z in mathcalD frac12 s(z_- z theta) - z_+_W^2,","category":"page"},{"location":"system_identification.html","page":"System Identification","title":"System Identification","text":"is used where mathcalD is a dataset of trajectories containing tuples (z_- z z_+) of state sequences, with system parameters theta in mathbfR^p, and where s  mathbfZ times mathbfZ times mathbfR^p rightarrow mathbfZ represents the simulator.","category":"page"},{"location":"system_identification.html","page":"System Identification","title":"System Identification","text":"A quasi-Newton method is employed to optimize the cost function and uses gradients:","category":"page"},{"location":"system_identification.html","page":"System Identification","title":"System Identification","text":"fracpartial Lpartial theta = fracpartial spartial theta^T W Big(s(z_- z theta) - z_+ Big),","category":"page"},{"location":"system_identification.html","page":"System Identification","title":"System Identification","text":"and the following Gauss-Newton approximation: ","category":"page"},{"location":"system_identification.html","page":"System Identification","title":"System Identification","text":"fracpartial^2 Lpartial theta^2 approx fracpartial spartial theta^T W fracpartial spartial theta,","category":"page"},{"location":"system_identification.html","page":"System Identification","title":"System Identification","text":"of the cost function Hessian, which only relies on Jacobians from Dojo.","category":"page"},{"location":"gradients.html#Gradients","page":"Gradients","title":"Gradients","text":"","category":"section"},{"location":"gradients.html#Implicit-Function-Theorem","page":"Gradients","title":"Implicit Function Theorem","text":"","category":"section"},{"location":"gradients.html","page":"Gradients","title":"Gradients","text":"An implicit function, r  mathbfR^n_w times mathbfR^n_theta rightarrow mathbfR^n_w, is defined as","category":"page"},{"location":"gradients.html","page":"Gradients","title":"Gradients","text":"r(w^* theta) = 0","category":"page"},{"location":"gradients.html","page":"Gradients","title":"Gradients","text":"for solution w^* in mathbfR^n_w and problem data theta in mathbfR^n_theta. At a solution point of the above equation the sensitivities of the solution with respect to the problem data, i.e., partial w^*  partial theta, can be computed under certain conditions. First, we approximate the above equation to first order:","category":"page"},{"location":"gradients.html","page":"Gradients","title":"Gradients","text":"  fracpartial rpartial w delta w + fracpartial rpartial theta delta theta = 0","category":"page"},{"location":"gradients.html","page":"Gradients","title":"Gradients","text":"and then solve for the relationship:","category":"page"},{"location":"gradients.html","page":"Gradients","title":"Gradients","text":"fracpartial w^*partial theta = -Big(fracpartial rpartial wBig)^-1 fracpartial rpartial theta quad quad(1)","category":"page"},{"location":"gradients.html","page":"Gradients","title":"Gradients","text":"In case (partial r  partial w)^-1 is not well defined, (e.g., not full rank) we can either apply regularization or approximately solve (1) with, for example, a least-squares approach.","category":"page"},{"location":"gradients.html","page":"Gradients","title":"Gradients","text":"Often, Newton's method is employed to find solutions to the implicit equation and custom linear-system solvers can efficiently compute search directions for this purpose. Importantly, the factorization of partial r  partial w used to find a solution can be reused to compute (1) at very low computational cost using only back-substitution. Additionally, each element of the problem-data sensitivity can be computed in parallel.","category":"page"},{"location":"gradients.html#Dojo's-Gradient","page":"Gradients","title":"Dojo's Gradient","text":"","category":"section"},{"location":"gradients.html","page":"Gradients","title":"Gradients","text":"At a solution point, w^*(theta kappa), the sensitivity of the solution with respect to the problem data, i.e., partial w^*  partial theta, is efficiently computed using the implicit-function theorem (1) to differentiate through the solver's residual.","category":"page"},{"location":"gradients.html","page":"Gradients","title":"Gradients","text":"The efficient linear-system solver used for the simulator, as well as the computation and factorization of partial r  partial w, is used to compute the sensitivities for each element of the problem data. Calculations over the individual columns of partial r  partial theta can be performed in parallel.","category":"page"},{"location":"gradients.html","page":"Gradients","title":"Gradients","text":"The problem data for each simulation step include: the previous and current configurations, control input, and additional terms like the time step, friction coefficients, and parameters of each body. The chain rule is utilized to compute gradients with respect to the finite-difference velocities as well as transformations between minimal- and maximal-coordinate representations.","category":"page"},{"location":"gradients.html","page":"Gradients","title":"Gradients","text":"In many robotics scenarios, we are interested in gradient information through contact events. Instead of computing gradients for hard contact with zero or very small central-path parameters, we use a relaxed value from intermediate solutions w^*(theta kappa  0) corresponding to a soft contact model. In practice, we find that these smooth gradients greatly improve the performance of gradient-based optimization methods.","category":"page"},{"location":"gradients.html#Gradient-Comparison","page":"Gradients","title":"Gradient Comparison","text":"","category":"section"},{"location":"gradients.html","page":"Gradients","title":"Gradients","text":"<img src=\"./assets/gradient_comparison.png\" width=\"500\"/>","category":"page"},{"location":"gradients.html","page":"Gradients","title":"Gradients","text":"Gradient comparison between randomized smoothing and Dojo's smooth gradients. The dynamics for a box in the XY plane that is resting on a flat surface and displaced an amount Delta by an input F (top left). Its corresponding exact gradients are shown in black. Gradient bundles (right column) are computed using sampling schemes with varying covariances Sigma and 500 samples. Dojo's gradients (middle column) are computed for different values of kappa, corresponding to the smoothness of the contact model. Compared to the 500-sample gradient bundle, Dojo's gradients are not noisy and are a 100 times faster to compute with a single worker.","category":"page"},{"location":"get_started.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"rexhopper_env.html#REx-Hopper","page":"REx Hopper","title":"REx Hopper","text":"","category":"section"},{"location":"contact_models.html#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"contact_models.html","page":"Overview","title":"Overview","text":"Impact and friction behaviors are modeled, along with the system’s dynamics, as a nonlinear complementarity problem (NCP). This model simulates hard contact without requiring system-specific solver tuning. Additionally, contacts between a system and the environment are treated as a single graph node connected to a rigid body (see below). As a result, the simulator retains efficient linear-time complexity for open-chain mechanical systems.","category":"page"},{"location":"contact_models.html","page":"Overview","title":"Overview","text":"(Image: graph)","category":"page"},{"location":"contact_models.html","page":"Overview","title":"Overview","text":"Three contact models are implemented in Dojo:","category":"page"},{"location":"contact_models.html","page":"Overview","title":"Overview","text":"ImpactContact enforces frictionless contact,\nNonlinearContact enforces contact with a non-linear cone of friction (second-order cone),","category":"page"},{"location":"contact_models.html","page":"Overview","title":"Overview","text":"(Image: nonlinear_cone)","category":"page"},{"location":"contact_models.html","page":"Overview","title":"Overview","text":"LinearContact enforces contact with a linearized cone of friction (pyramidal cone).","category":"page"},{"location":"contact_models.html","page":"Overview","title":"Overview","text":"(Image: linearized_cone)","category":"page"},{"location":"contact_models.html","page":"Overview","title":"Overview","text":"All 3 of these contact models implement hard contact i.e., no interpenetration. This means that for both the nonlinear and linearized cones, we concatenate the constraints resulting from friction with the impact constraints.","category":"page"},{"location":"contact_models.html#Implementation","page":"Overview","title":"Implementation","text":"","category":"section"},{"location":"contact_models.html","page":"Overview","title":"Overview","text":"Dojo currently supports contact constraints occurring between a sphere and the ground i.e., a horizontal half-space of altitude 0.0. Each spherical contact is attached to a single Body.","category":"page"},{"location":"contact_models.html","page":"Overview","title":"Overview","text":"To create a new point of contact, we need to define:","category":"page"},{"location":"contact_models.html","page":"Overview","title":"Overview","text":"the Body to which the contact constraint is attached\nradius of the sphere defining the spherical contact\ncoefficient of friction (except for ImpactContact)","category":"page"},{"location":"contact_models.html#Example","page":"Overview","title":"Example","text":"","category":"section"},{"location":"contact_models.html","page":"Overview","title":"Overview","text":"For the Quadruped model shown in the picture below, we defined 12 contacts spheres show in red:","category":"page"},{"location":"contact_models.html","page":"Overview","title":"Overview","text":"4 for the feet,\n4 for the knees,\n4 for for the hips.","category":"page"},{"location":"contact_models.html","page":"Overview","title":"Overview","text":"(Image: quadruped_contact)","category":"page"},{"location":"maximal_representation.html#Maximal-Coordinates","page":"Maximal Coordinates","title":"Maximal Coordinates","text":"","category":"section"},{"location":"maximal_representation.html","page":"Maximal Coordinates","title":"Maximal Coordinates","text":"The i-th body in a mechanism with N bodies has state:  ","category":"page"},{"location":"maximal_representation.html","page":"Maximal Coordinates","title":"Maximal Coordinates","text":"z^(i) = (x^(i) v^(i) q^(i) omega^(i)) in mathbfR^3 times mathbfR^3 times mathbfH times mathbfR^3","category":"page"},{"location":"maximal_representation.html","page":"Maximal Coordinates","title":"Maximal Coordinates","text":"represented in maximal coordinates, where mathbfH is the space of unit quaternions. ","category":"page"},{"location":"maximal_representation.html","page":"Maximal Coordinates","title":"Maximal Coordinates","text":"x: position in world frame\nv: linear velocity in the world frame\nq: orientation represented as a unit quaternion\nomega: angular velocity in the body frame","category":"page"},{"location":"maximal_representation.html","page":"Maximal Coordinates","title":"Maximal Coordinates","text":"The mechanism state:   ","category":"page"},{"location":"maximal_representation.html","page":"Maximal Coordinates","title":"Maximal Coordinates","text":"z = (z^(1) dots z^(N))","category":"page"},{"location":"maximal_representation.html","page":"Maximal Coordinates","title":"Maximal Coordinates","text":"is the concatentation of all body states.","category":"page"},{"location":"nonlinear_friction.html#Nonlinear-friction","page":"Nonlinear friction","title":"Nonlinear friction","text":"","category":"section"},{"location":"nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"In contrast to a LCP approach, we utilize the optimality conditions of in a form amenable to a primal-dual interior-point solver. The associated cone program is,","category":"page"},{"location":"nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"beginalign*\nundersetbetatextminimize  hspace05em beginbmatrix 0  v^T endbmatrix beta\ntextsubject to  hspace05em beta_(1) = mu gamma \n hspace05em beta in mathcalQ^3\nendalign*","category":"page"},{"location":"nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"where subscripts indicate vector indices and the n-dimensional second-order cone mathcalQ^n is defined by:","category":"page"},{"location":"nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"mathcalQ^n = (a_(1) a_(2n)) in mathbfR times mathbfR^n-1   a_(2n)_2 leq a_(1) ","category":"page"},{"location":"nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"The relaxed optimality conditions for the above problem in interior-point form are:","category":"page"},{"location":"nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"beginalign* \nv - eta_(23) = 0 \nbeta_(1) - mu gamma = 0 \nbeta circ eta =  kappa mathbfe \nbeta eta in mathcalQ^3\nendalign*","category":"page"},{"location":"nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"with dual variable eta in mathcalQ^3 associated with the second-order-cone constraints, and central-path parameter, kappa in mathbfR_+. The second-order-cone product is:","category":"page"},{"location":"nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"beta circ eta = (beta^T eta beta_(1) eta_(2n) + eta_(1) beta_(2n))","category":"page"},{"location":"nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"and,","category":"page"},{"location":"nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"mathbfe = (1 0 dots 0)","category":"page"},{"location":"nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"is its corresponding identity element. Friction is recovered from the solution: b = beta^*_(23). The benefits of this model are increased physical fidelity and fewer optimization variables, without substantial increase in computational cost.","category":"page"},{"location":"nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"Nonlinear complementarity problem: To simulate a system represented in maximal coordinates that experiences contact, a solver aims to satisfy the following relaxed feasibility problem:","category":"page"},{"location":"nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"beginalign*\ntextfind  quad z_+ w gamma beta^(1P) eta^(1P) s\ntextst  quad f(z_- z z_+ w) + B(z) u + C(z)^T lambda = 0 \n quad s - phi(z_+) = 0 \n quad gamma circ s = kappa textbf1 \n quad beta^(i) circ eta^(i) = kappa mathbfe  quad i = 1 dots P\n quad v^(i)(z z_+) - eta_(23)^(i) = 0  quad i = 1 dots P \n quad beta^(i)_(1) - mu^(i) gamma^(i) = 0  quad i = 1 dots P\n quad gamma s geq 0\n quad beta^(i) eta^(i) in mathcalQ^3  quad i = 1 dots P\nendalign*","category":"page"},{"location":"nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"where u in mathbfR^m is the control input at the current time step, lambda = (beta^(1)_(23) gamma^(1) dots beta^(P)_(23) gamma^(P)) in mathbfLambda is the concatenation of impact and friction impulses, B  mathbfZ rightarrow mathbfR^6N times m is the input Jacobian mapping control inputs into maximal coordinates, C  mathbfZ rightarrow mathbfR^textdim(mathbfLambda) times 6N is a contact Jacobian mapping between maximal coordinates and contact surfaces, s in mathbfR^P is a slack variable introduced for convenience, and v^(i)  mathbfZ times mathbfZ rightarrow mathbfR^2 is the tangential velocity at contact point i. Joint limits and internal friction are readily incorporated into this problem formulation.","category":"page"},{"location":"notations.html#Notations","page":"Notations","title":"Notations","text":"","category":"section"},{"location":"notations.html#General-notations","page":"Notations","title":"General notations","text":"","category":"section"},{"location":"notations.html","page":"Notations","title":"Notations","text":"O is the origin of the frame\nCA is the center of mass of body A\nPA is a point attached to body A\n_W corresponds to the world frame\n_A corresponds to the A frame \nCA_W is the center of mass of body A expressed in the world frame ","category":"page"},{"location":"notations.html#Body-notations","page":"Notations","title":"Body notations","text":"","category":"section"},{"location":"notations.html","page":"Notations","title":"Notations","text":"Body A's state is represented by ","category":"page"},{"location":"notations.html","page":"Notations","title":"Notations","text":"x = CA_W 3 dimensional position of the center of mass of body A expressed in the world frame W.\nv = V(CA, A / W)_W 3 dimensional velocity of the CA attached to body A with respect to the world frame W expressed in the world frame W.\nq = RWA quaternion representing the rotation from body A' frame to the world frame W, e.g. PW = RWA * PA. RWA is the matrix form of q.\nphi = Omega(A/W)_A angular velocity of body A with respect to the world frame, expressed in body A's frame.","category":"page"},{"location":"atlas_env.html#Atlas","page":"Atlas","title":"Atlas","text":"","category":"section"},{"location":"citing.html#Citing","page":"Citing","title":"Citing","text":"","category":"section"},{"location":"citing.html","page":"Citing","title":"Citing","text":"If you find Dojo useful in your project, we kindly request that you cite the following paper:","category":"page"},{"location":"citing.html","page":"Citing","title":"Citing","text":"@article{howelllecleach2022dojo,\n\ttitle={Dojo: {A} {D}ifferentiable {S}imulator for {R}obotics},\n\tauthor={Howell, Taylor A. and Le Cleac'h, Simon and and Kolter, J. Zico and Schwager, Mac and Manchester, Zachary},\n\tyear={2022}\n}","category":"page"},{"location":"citing.html","page":"Citing","title":"Citing","text":"A preprint can be downloaded from arXiv.","category":"page"},{"location":"index.html#Get-Started","page":"Get Started","title":"Get Started","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Dojo is a differentiable simulator for robotics, prioritizing accurate physics and useful gradients. The simulator is written in pure Julia in order to be both performant and easy to use.","category":"page"},{"location":"index.html#Features","page":"Get Started","title":"Features","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Maximal-Coordinates Representation: Fast and efficient conversion between maximal and minimal representations\nSmooth Gradients: Simulation with hard contact and useful gradients through contact events\nOpen Source: Code is available on GitHub and distributed under the MIT Licence\nPython Interface: dojopy","category":"page"},{"location":"index.html#Installation","page":"Get Started","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Dojo can be installed using the Julia package manager for Julia v1.6 and higher. Inside the Julia REPL, type ] to enter the Pkg REPL mode then run","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"pkg> add Dojo","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"If you want to install the latest version from main run","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"pkg> add Dojo#main","category":"page"},{"location":"index.html#Related-talks","page":"Get Started","title":"Related talks","text":"","category":"section"},{"location":"index.html#Credits","page":"Get Started","title":"Credits","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"The following people are involved in the development of Dojo:","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Primary Development","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Simon Le Cleac'h (main developement, contact modeling, interior-point solver, gradients)\nTaylor Howell (main developement, contact modeling, interior-point solver, gradients)\nJan Bruedigam (main development, maximal representation and graph-based solver)","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Zico Kolter\nMac Schwager\nZachary Manchester (principal investigator)","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Additional Contributions","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Suvansh Sanjeev (PyTorch interface)\nBenjamin Bokser (REx Hopper)","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Development by the Robotic Exploration Lab.","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"If this project is useful for your work please consider","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Citing the relevant papers\nLeaving a star on the GitHub repository","category":"page"},{"location":"index.html#Licence","page":"Get Started","title":"Licence","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Dojo.jl is licensed under the MIT License. For more details click here.","category":"page"}]
}
